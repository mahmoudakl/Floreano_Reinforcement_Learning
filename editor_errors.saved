{"data":{"TF":[{"id":0,"name":"Brain2Motor","code":"\"\"\"\nThe transfer function which calculates the linear twist of the husky robot based on the\nvoltage of left and right wheel neurons.\n:param t: the current simulation time\n:param left_wheel_forward_neuron: the left wheel forward neuron device\n:param left_wheel_back_neuron: the left wheel back neuron device\n:param right_wheel_forward_neuron: the right wheel forward neuron device\n:param right_wheel_back_neuron: the right wheel back neuron device\n:return: a gazebo_msgs/WheelSpeeds setting the speeds of the left and right pair of wheels of the husky robot for movement.\n\"\"\"\nleft_wheel = 0.002 * (left_wheel_forward_neuron.rate - left_wheel_back_neuron.rate)\nright_wheel = 0.002 * (right_wheel_forward_neuron.rate - right_wheel_back_neuron.rate)\nideal_wheel_speed.value = [left_wheel, right_wheel]\nreturn gazebo_msgs.msg.WheelSpeeds(left_wheel, right_wheel, left_wheel, right_wheel)","dirty":false,"local":false,"error":{},"type":2,"oldName":"Brain2Motor","devices":[{"neurons":{"name":"actors","stop":1,"ids":[],"start":0,"step":1,"type":1},"type":"PopulationRate","name":"left_wheel_forward_neuron"},{"neurons":{"name":"actors","stop":2,"ids":[],"start":1,"step":1,"type":1},"type":"PopulationRate","name":"left_wheel_back_neuron"},{"neurons":{"name":"actors","stop":3,"ids":[],"start":2,"step":1,"type":1},"type":"PopulationRate","name":"right_wheel_forward_neuron"},{"neurons":{"name":"actors","stop":4,"ids":[],"start":3,"step":1,"type":1},"type":"PopulationRate","name":"right_wheel_back_neuron"}],"topics":[{"topic":"/husky/wheel_speeds","type":"gazebo_msgs/WheelSpeeds","name":"__return__","publishing":true,"isDefault":true}],"variables":[{"type":"list","name":"ideal_wheel_speed","initial_value":"[0.0, 0.0]"}],"rawCode":"# Imported Python Transfer Function\n\"\"\"\nThis module contains the transfer function which is responsible for determining the linear twist\ncomponent of the husky's movement based on the left and right wheel neuron\n\"\"\"\nimport hbp_nrp_cle.tf_framework as nrp\nfrom hbp_nrp_cle.robotsim.RobotInterface import Topic\nimport gazebo_msgs.msg\n@nrp.MapSpikeSink(\"left_wheel_forward_neuron\", nrp.brain.actors[0], nrp.population_rate)\n@nrp.MapSpikeSink(\"left_wheel_back_neuron\", nrp.brain.actors[1], nrp.population_rate)\n@nrp.MapSpikeSink(\"right_wheel_forward_neuron\", nrp.brain.actors[2], nrp.population_rate)\n@nrp.MapSpikeSink(\"right_wheel_back_neuron\", nrp.brain.actors[3], nrp.population_rate)\n@nrp.MapVariable(\"ideal_wheel_speed\", global_key=\"ideal_wheel_speed\", initial_value=[0.0,0.0], scope=nrp.GLOBAL)\n@nrp.Neuron2Robot(Topic('/husky/wheel_speeds', gazebo_msgs.msg.WheelSpeeds))\ndef Brain2Motor(t, ideal_wheel_speed, left_wheel_forward_neuron, left_wheel_back_neuron, right_wheel_forward_neuron, right_wheel_back_neuron):\n    \"\"\"\n    The transfer function which calculates the linear twist of the husky robot based on the\n    voltage of left and right wheel neurons.\n    :param t: the current simulation time\n    :param left_wheel_forward_neuron: the left wheel forward neuron device\n    :param left_wheel_back_neuron: the left wheel back neuron device\n    :param right_wheel_forward_neuron: the right wheel forward neuron device\n    :param right_wheel_back_neuron: the right wheel back neuron device\n    :return: a gazebo_msgs/WheelSpeeds setting the speeds of the left and right pair of wheels of the husky robot for movement.\n    \"\"\"\n    left_wheel = 0.002 * (left_wheel_forward_neuron.rate - left_wheel_back_neuron.rate)\n    right_wheel = 0.002 * (right_wheel_forward_neuron.rate - right_wheel_back_neuron.rate)\n    ideal_wheel_speed.value = [left_wheel, right_wheel]\n    return gazebo_msgs.msg.WheelSpeeds(left_wheel, right_wheel, left_wheel, right_wheel)\n","active":true},{"id":1,"name":"csv_spike_monitor","code":"for i in range(0, len(record_neurons.times)):\n    recorder.record_entry(\n        record_neurons.times[i][0],\n        record_neurons.times[i][1]\n    )","dirty":false,"local":false,"error":{},"type":2,"oldName":"csv_spike_monitor","devices":[{"neurons":{"name":"record","stop":0,"ids":[],"start":0,"step":0,"type":0},"type":"SpikeRecorder","name":"record_neurons"}],"topics":[{"topic":"/monitor/spike_recorder","type":"cle_ros_msgs/SpikeEvent","name":"__return__","publishing":true,"isDefault":true}],"variables":[{"type":"csv","name":"recorder","initial_value":"{\"headers\": [\"id\", \"time\"], \"filename\": \"all_spikes.csv\"}","filename":"all_spikes.csv","headers":["id","time"]}],"rawCode":"# Imported Python Transfer Function\n@nrp.MapCSVRecorder(\"recorder\", filename=\"all_spikes.csv\", headers=[\"id\", \"time\"])\n@nrp.MapSpikeSink(\"record_neurons\", nrp.brain.record, nrp.spike_recorder)\n@nrp.Neuron2Robot(Topic('/monitor/spike_recorder', cle_ros_msgs.msg.SpikeEvent))\ndef csv_spike_monitor(t, recorder, record_neurons):\n    for i in range(0, len(record_neurons.times)):\n        recorder.record_entry(\n            record_neurons.times[i][0],\n            record_neurons.times[i][1]\n        )\n","active":true},{"id":2,"name":"all_neurons_spike_monitor","code":"# Uncomment to log into the 'log-console' visible in the simulation\n# clientLogger.info(\"Time: \", t)\nreturn True","dirty":false,"local":false,"error":{},"type":3,"oldName":"all_neurons_spike_monitor","devices":[{"neurons":{"name":"record","stop":0,"ids":[],"start":0,"step":0,"type":0},"type":"SpikeRecorder","name":"device"}],"topics":[{"topic":"/monitor/spike_recorder","type":"cle_ros_msgs/SpikeEvent","name":"publisher","publishing":true,"isDefault":false}],"variables":[],"rawCode":"# Imported Python Transfer Function\nimport hbp_nrp_cle.tf_framework as nrp\n# This specifies that the neurons 0 to 2 of the circuit population\n# should be monitored. You can see them in the spike train widget\n@nrp.NeuronMonitor(nrp.brain.record, nrp.spike_recorder)\ndef all_neurons_spike_monitor(t):\n  # Uncomment to log into the 'log-console' visible in the simulation\n  # clientLogger.info(\"Time: \", t)\n  return True\n","active":true},{"id":3,"name":"csv_wheel_speeds","code":"if not isinstance(joint_state.value, type(None)):\n    recorder.record_entry(t, joint_state.value.velocity[0]*(0.3555/2.0), joint_state.value.velocity[1]*(0.3555/2.0))\n    #clientLogger.info(\"WHEEL SPEEDS @  %s: %s, %s\" % (str(t),\n    #                                                  joint_state.value.velocity[0]*(0.3555/2.0),\n    #                                                  joint_state.value.velocity[1]*(0.3555/2.0)))","dirty":false,"local":false,"error":{},"type":1,"oldName":"csv_wheel_speeds","devices":[],"topics":[{"topic":"/joint_states","type":"gazebo_msgs/ModelStates","name":"joint_state","publishing":false,"isDefault":false}],"variables":[{"type":"csv","name":"recorder","initial_value":"{\"headers\": [\"time\", \"Left_wheel_speed\", \"Right_wheel_speed\"], \"filename\": \"wheel_speeds.csv\"}","filename":"wheel_speeds.csv","headers":["time","Left_wheel_speed","Right_wheel_speed"]}],"rawCode":"# Imported Python Transfer Function\n@nrp.MapCSVRecorder(\"recorder\", filename=\"wheel_speeds.csv\", headers=[\"time\", \"Left_wheel_speed\", \"Right_wheel_speed\"])\n@nrp.MapRobotSubscriber(\"joint_state\", Topic('/joint_states', gazebo_msgs.msg.ModelStates))\n@nrp.Robot2Neuron()\ndef csv_wheel_speeds(t, joint_state, recorder):\n    if not isinstance(joint_state.value, type(None)):\n        recorder.record_entry(t, joint_state.value.velocity[0]*(0.3555/2.0), joint_state.value.velocity[1]*(0.3555/2.0))\n        #clientLogger.info(\"WHEEL SPEEDS @  %s: %s, %s\" % (str(t),\n        #                                                  joint_state.value.velocity[0]*(0.3555/2.0),\n        #                                                  joint_state.value.velocity[1]*(0.3555/2.0)))\n","active":true},{"id":4,"name":"csv_robot_position","code":"if not isinstance(position.value, type(None)):\n    # determine if previously set robot index has changed\n    if robot_index.value is not None:\n        # if the value is invalid, reset the index below\n        if robot_index.value >= len(position.value.name) or\\\n           position.value.name[robot_index.value] != 'robot':\n            robot_index.value = None\n    # robot index is invalid, find and set it\n    if robot_index.value is None:\n        # 'robot' is guaranteed by the NRP, if not found raise error\n        robot_index.value = position.value.name.index('robot')\n    # record the current robot position\n    recorder.record_entry(position.value.pose[robot_index.value].position.x,\n                          position.value.pose[robot_index.value].position.y,\n                          position.value.pose[robot_index.value].position.z)","dirty":false,"local":false,"error":{},"type":1,"oldName":"csv_robot_position","devices":[],"topics":[{"topic":"/gazebo/model_states","type":"gazebo_msgs/ModelStates","name":"position","publishing":false,"isDefault":false}],"variables":[{"type":"csv","name":"recorder","initial_value":"{\"headers\": [\"x\", \"y\", \"z\"], \"filename\": \"robot_position.csv\"}","filename":"robot_position.csv","headers":["x","y","z"]},{"type":"NoneType","name":"robot_index","initial_value":"None"}],"rawCode":"# Imported Python Transfer Function\n@nrp.MapCSVRecorder(\"recorder\", filename=\"robot_position.csv\", headers=[\"x\", \"y\", \"z\"])\n@nrp.MapRobotSubscriber(\"position\", Topic('/gazebo/model_states', gazebo_msgs.msg.ModelStates))\n@nrp.MapVariable(\"robot_index\", global_key=\"robot_index\", initial_value=None)\n@nrp.Robot2Neuron()\ndef csv_robot_position(t, position, recorder, robot_index):\n    if not isinstance(position.value, type(None)):\n        # determine if previously set robot index has changed\n        if robot_index.value is not None:\n            # if the value is invalid, reset the index below\n            if robot_index.value >= len(position.value.name) or\\\n               position.value.name[robot_index.value] != 'robot':\n                robot_index.value = None\n        # robot index is invalid, find and set it\n        if robot_index.value is None:\n            # 'robot' is guaranteed by the NRP, if not found raise error\n            robot_index.value = position.value.name.index('robot')\n        # record the current robot position\n        recorder.record_entry(position.value.pose[robot_index.value].position.x,\n                              position.value.pose[robot_index.value].position.y,\n                              position.value.pose[robot_index.value].position.z)\n","active":true},{"id":5,"name":"csv_joint_state_monitor","code":"if not isinstance(joint_state.value, type(None)):\n    for i in range(0, len(joint_state.value.name)):\n        recorder.record_entry(joint_state.value.name[i], t, joint_state.value.position[i])","dirty":false,"local":false,"error":{},"type":1,"oldName":"csv_joint_state_monitor","devices":[],"topics":[{"topic":"/joint_states","type":"sensor_msgs/JointState","name":"joint_state","publishing":false,"isDefault":false}],"variables":[{"type":"csv","name":"recorder","initial_value":"{\"headers\": [\"Name\", \"time\", \"Position\"], \"filename\": \"all_joints_positions.csv\"}","filename":"all_joints_positions.csv","headers":["Name","time","Position"]}],"rawCode":"# Imported Python Transfer Function\n@nrp.MapRobotSubscriber(\"joint_state\", Topic('/joint_states', sensor_msgs.msg.JointState))\n@nrp.MapCSVRecorder(\"recorder\", filename=\"all_joints_positions.csv\", headers=[\"Name\", \"time\", \"Position\"])\n@nrp.Robot2Neuron()\ndef csv_joint_state_monitor(t, joint_state, recorder):\n    if not isinstance(joint_state.value, type(None)):\n        for i in range(0, len(joint_state.value.name)):\n            recorder.record_entry(joint_state.value.name[i], t, joint_state.value.position[i])\n","active":true},{"id":6,"name":"Sensor2Brain","code":"bridge = CvBridge()\nif not isinstance(camera.value, type(None)):\n    #clientLogger.info(camera.value)\n    (thresh, im_bw) = cv2.threshold(bridge.imgmsg_to_cv2(camera.value, \"mono8\"), 128, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)\n    #clientLogger.info(im_bw)\n    iws = np.array(ideal_wheel_speed.value)\n    rws = np.array(real_wheel_speed.value)\n    visual_receptors = [r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16]\n    for i in range(len(visual_receptors)):\n        rate = (im_bw.item((4*i))/6.0 + im_bw.item((4*i)+1)/3.0 + im_bw.item((4*i)+2)/3.0 + im_bw.item((4*i)+3)/6.0)/255.\n        if np.random.rand() <= rate:\n        \tvisual_receptors[i].rate = 1.0\n        else:\n            visual_receptors[i].rate = 0.0\n    for n in range(len(r17)):\n        r17[n].rate = 100000*np.absolute(iws[0]-rws[0])\n    for n in range(len(r18)):\n        r18[n].rate = 100000*np.absolute(iws[1]-rws[1])","dirty":false,"local":false,"error":{"Runtime":{"lineText":"","functionName":"Sensor2Brain","errorType":"Runtime","offset":-1,"fileName":"","sourceType":"Transfer Function","lineNumber":36,"message":"index 22 is out of bounds for size 22","severity":1}},"type":1,"oldName":"Sensor2Brain","devices":[{"neurons":{"name":" <function <lambda.18> at 0x7fd2521b0668>","stop":0,"ids":[],"start":0,"step":0,"type":0},"type":"Poisson","name":"r1"},{"neurons":{"name":" <function <lambda.19> at 0x7fd2521b0410>","stop":0,"ids":[],"start":0,"step":0,"type":0},"type":"Poisson","name":"r2"},{"neurons":{"name":" <function <lambda.20> at 0x7fd2521b0398>","stop":0,"ids":[],"start":0,"step":0,"type":0},"type":"Poisson","name":"r3"},{"neurons":{"name":" <function <lambda.21> at 0x7fd2521b0320>","stop":0,"ids":[],"start":0,"step":0,"type":0},"type":"Poisson","name":"r4"},{"neurons":{"name":" <function <lambda.22> at 0x7fd2521b05f0>","stop":0,"ids":[],"start":0,"step":0,"type":0},"type":"Poisson","name":"r5"},{"neurons":{"name":" <function <lambda.23> at 0x7fd2521b0578>","stop":0,"ids":[],"start":0,"step":0,"type":0},"type":"Poisson","name":"r6"},{"neurons":{"name":" <function <lambda.24> at 0x7fd2521b0500>","stop":0,"ids":[],"start":0,"step":0,"type":0},"type":"Poisson","name":"r7"},{"neurons":{"name":" <function <lambda.25> at 0x7fd2521b0488>","stop":0,"ids":[],"start":0,"step":0,"type":0},"type":"Poisson","name":"r8"},{"neurons":{"name":" <function <lambda.26> at 0x7fd252c46f50>","stop":0,"ids":[],"start":0,"step":0,"type":0},"type":"Poisson","name":"r9"},{"neurons":{"name":" <function <lambda.27> at 0x7fd252c46ed8>","stop":0,"ids":[],"start":0,"step":0,"type":0},"type":"Poisson","name":"r10"},{"neurons":{"name":" <function <lambda.28> at 0x7fd252c46e60>","stop":0,"ids":[],"start":0,"step":0,"type":0},"type":"Poisson","name":"r11"},{"neurons":{"name":" <function <lambda.29> at 0x7fd252c46de8>","stop":0,"ids":[],"start":0,"step":0,"type":0},"type":"Poisson","name":"r12"},{"neurons":{"name":" <function <lambda.30> at 0x7fd252c46d70>","stop":0,"ids":[],"start":0,"step":0,"type":0},"type":"Poisson","name":"r13"},{"neurons":{"name":" <function <lambda.31> at 0x7fd252c46cf8>","stop":0,"ids":[],"start":0,"step":0,"type":0},"type":"Poisson","name":"r14"},{"neurons":{"name":" <function <lambda.32> at 0x7fd252c46c80>","stop":0,"ids":[],"start":0,"step":0,"type":0},"type":"Poisson","name":"r15"},{"neurons":{"name":" <function <lambda.33> at 0x7fd252c46c08>","stop":0,"ids":[],"start":0,"step":0,"type":0},"type":"Poisson","name":"r16"},{"neurons":{"name":" <function <lambda.34> at 0x7fd252c46b90>","stop":0,"ids":[],"start":0,"step":0,"type":0},"type":"Poisson","name":"r17"},{"neurons":{"name":" <function <lambda.35> at 0x7fd252c46b18>","stop":0,"ids":[],"start":0,"step":0,"type":0},"type":"Poisson","name":"r18"}],"topics":[{"topic":"/husky/camera","type":"sensor_msgs/Image","name":"camera","publishing":false,"isDefault":false}],"variables":[{"type":"list","name":"ideal_wheel_speed","initial_value":"[0.0, 0.0]"},{"type":"list","name":"real_wheel_speed","initial_value":"[0.0, 0.0]"}],"rawCode":"# Imported Python Transfer Function\nimport numpy as np\nimport cv2\n@nrp.MapRobotSubscriber(\"camera\", Topic('/husky/camera', sensor_msgs.msg.Image))  \n@nrp.MapVariable(\"ideal_wheel_speed\", global_key=\"ideal_wheel_speed\", initial_value=[0.0,0.0], scope=nrp.GLOBAL)\n@nrp.MapVariable(\"real_wheel_speed\", global_key=\"real_wheel_speed\", initial_value=[0.0,0.0], scope=nrp.GLOBAL)\n@nrp.MapSpikeSource(\"r1\", nrp.map_neurons(nrp.brain.receptors[0], lambda i: nrp.brain.brain[i]), nrp.poisson)\n@nrp.MapSpikeSource(\"r2\", nrp.map_neurons(nrp.brain.receptors[1], lambda i: nrp.brain.brain[i]), nrp.poisson)\n@nrp.MapSpikeSource(\"r3\", nrp.map_neurons(nrp.brain.receptors[2], lambda i: nrp.brain.brain[i]), nrp.poisson)\n@nrp.MapSpikeSource(\"r4\", nrp.map_neurons(nrp.brain.receptors[3], lambda i: nrp.brain.brain[i]), nrp.poisson)\n@nrp.MapSpikeSource(\"r5\", nrp.map_neurons(nrp.brain.receptors[4], lambda i: nrp.brain.brain[i]), nrp.poisson)\n@nrp.MapSpikeSource(\"r6\", nrp.map_neurons(nrp.brain.receptors[5], lambda i: nrp.brain.brain[i]), nrp.poisson)\n@nrp.MapSpikeSource(\"r7\", nrp.map_neurons(nrp.brain.receptors[6], lambda i: nrp.brain.brain[i]), nrp.poisson)\n@nrp.MapSpikeSource(\"r8\", nrp.map_neurons(nrp.brain.receptors[7], lambda i: nrp.brain.brain[i]), nrp.poisson)\n@nrp.MapSpikeSource(\"r9\", nrp.map_neurons(nrp.brain.receptors[8], lambda i: nrp.brain.brain[i]), nrp.poisson)\n@nrp.MapSpikeSource(\"r10\", nrp.map_neurons(nrp.brain.receptors[9], lambda i: nrp.brain.brain[i]), nrp.poisson)\n@nrp.MapSpikeSource(\"r11\", nrp.map_neurons(nrp.brain.receptors[10], lambda i: nrp.brain.brain[i]), nrp.poisson)\n@nrp.MapSpikeSource(\"r12\", nrp.map_neurons(nrp.brain.receptors[11], lambda i: nrp.brain.brain[i]), nrp.poisson)\n@nrp.MapSpikeSource(\"r13\", nrp.map_neurons(nrp.brain.receptors[12], lambda i: nrp.brain.brain[i]), nrp.poisson)\n@nrp.MapSpikeSource(\"r14\", nrp.map_neurons(nrp.brain.receptors[13], lambda i: nrp.brain.brain[i]), nrp.poisson)\n@nrp.MapSpikeSource(\"r15\", nrp.map_neurons(nrp.brain.receptors[14], lambda i: nrp.brain.brain[i]), nrp.poisson)\n@nrp.MapSpikeSource(\"r16\", nrp.map_neurons(nrp.brain.receptors[15], lambda i: nrp.brain.brain[i]), nrp.poisson)\n@nrp.MapSpikeSource(\"r17\", nrp.map_neurons(nrp.brain.receptors[16], lambda i: nrp.brain.brain[i]), nrp.poisson)\n@nrp.MapSpikeSource(\"r18\", nrp.map_neurons(nrp.brain.receptors[17], lambda i: nrp.brain.brain[i]), nrp.poisson)\n@nrp.Robot2Neuron()\ndef Sensor2Brain(t, ideal_wheel_speed, real_wheel_speed, camera, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18):\n    bridge = CvBridge()\n    if not isinstance(camera.value, type(None)):\n        #clientLogger.info(camera.value)\n        (thresh, im_bw) = cv2.threshold(bridge.imgmsg_to_cv2(camera.value, \"mono8\"), 128, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)\n        #clientLogger.info(im_bw)\n        iws = np.array(ideal_wheel_speed.value)\n        rws = np.array(real_wheel_speed.value)\n        visual_receptors = [r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16]\n        for i in range(len(visual_receptors)):\n            rate = (im_bw.item((4*i))/6.0 + im_bw.item((4*i)+1)/3.0 + im_bw.item((4*i)+2)/3.0 + im_bw.item((4*i)+3)/6.0)/255.\n            if np.random.rand() <= rate:\n            \tvisual_receptors[i].rate = 1.0\n            else:\n                visual_receptors[i].rate = 0.0\n        for n in range(len(r17)):\n            r17[n].rate = 100000*np.absolute(iws[0]-rws[0])\n        for n in range(len(r18)):\n            r18[n].rate = 100000*np.absolute(iws[1]-rws[1])\n","active":true}]},"__owner_id":"default-owner"}